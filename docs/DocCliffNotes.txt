================================================================================
Serial Checker: [Napkin Notes] General User Story/Case stuff
================================================================================
SW Arch/Design Notes

(Assume temporarily there's no LCD/UI- what's our SW architecture?)
	DriverLayer
		Joystick- Two ADC measured values (X and Y)
		Buttons- Two digital buttons
		GPIOs- Four digital pin values (all/most bidirectional)
		UART/USB- Transmit only UART connection
		(Watchdog/reset device- TBD)
	DeviceLayer
		Joystick abstracted to 5 values (directions + center)
		Buttons abstracted to High/Low
		GPIO_Read abstracted to High/Low
		GPIO_Drive abstracted to On/Off and High/Low
	App/StateLayer
		serial function must be consulted for interpreting triggers/response behavior
		ui function must be consulted for interpreting where/what the cursor is on

General Layers
	AppLayer- Business/State Logic Level Code
	DriverLayer- Drivers directly controlling HW
	Utils- Utilities abstracting generic processes/services
	DomainLayer- Data types "gluing" other layers together

HW Implements
	Joystick
		reports 2 values to indicate x/y directions
		likely will want as just 4
		should consider debouncing ("analog" debounce)
		will need to determine switching behavior (back to center, or bypass it?)
		should consider if "hold" mechanics are needed, or just "move per iteration"
	Buttons x 2
		both report on/off
		should consider debouncing
		likely will divide into "confirm" and "cancel" behavior
	GPIO x 4
		each reports on/off value
		consider debouncing
		direction may change on pins
		pins are read off reagardless of direction
	LCD screen
		used to show/report data
		directly, its a SPI port to MCU- though could "abstract" as screen
		likely will want abstract view of screen regardless (ie 7x7 grid, UI elements figured out beforehand)
	Timer
		Will need something to track at 1 ms intervals
		this can likely be shared easily
	UART/USB
		pretty easy, only need output for exporting
		will need to stream data over it however- up to ~ 2 KB
	Reset
		May want some from of reset element for asserting
		reset may have HW level watchdog/HW reset implements

Ideas on Devices
	Joystick Device- simplifies joystick directions (handles debounce/direction logic)
	Buttons Device- simplifies both/all buttons (handles debounce/direction logic)
	GPIO Device- simplifies updating/sampling of pins
	LCD Device- simplifies updating of screen

================================================================================
Chicken Scratchings/To Sort

Use Case/Feature Breakdown

General States
	Main Menu (select a serial)
	Serial Off/Paused
	Serial Live/Scanning
	Serial Active/Sampling

Configurable Options
	Sample Rate
	Sample Size
	Sample Trigger Type
	Response Trigger Type
	Response Value A
	Response Value B

Ideas on Set Options
	Sample Triggers- on button press (in scanning state), on preset pin rising/falling edge
	Response Triggers- on button press (in scanning state), on preset pin(s) rising falling edge, on reception of data

Response Values Per Serial
	GPIO- transition values for each output pin?
	UART- 2 byte value and select (1-2 bytes or echo)
	I2C- address and read value
	SPI- 2 byte value and select (bytes or echo)

Data Types Entered by User
	"Drop Down Box" Input (i.e. preset options- choose one)
	Integer value (likely "drop down box" per digit- hex would simplify some selection)

Types of Displays
	Text- Typically in some sort of "selection" box
	Digits- Also likely in some sort of box
	Waveforms- digital waves showing live and past data values
	Symbols- Minor symbols to indicate actions to take (or being taken)
		e.g. arrows for indicating controls, smaller text "symbols" indicating state or actions being taken
	"Indicators"- something to indicate selected or selectable objects (e.g. boxes, inversions)
		(will have to be able to put "over" or "on" other displayed info)


Selections
	Sample Rate (Hz) = {10, 50, 100, 500, 1000}
	Sample Size (#)  = {10, 50, 100, 500, 1000, 2000}
	Trigger Type
		GPIO = button press, posedge1, negedge1, posedge2, negedge2
		UART = button press, negedgeT, negedgeR
		I2C  = button press, posedgeC, negedgeC
		SPI  = button press, posedgeS, negedgeS
	Response Triggers
		GPIO = button press, posedge1, negedge1, posedge2, negedge2, off
		UART = button press, negedgeT, receive char, off
		I2C  = -
		SPI  = -
	Response Types
		GPIO = pos vs neg for both pins
		UART = # bytes to send (1-2) and value(s)
		I2C  = 16b address and 16b value
		SPI  = pattern {hold low, hold high, shift on rotate} and value

================================================================================
